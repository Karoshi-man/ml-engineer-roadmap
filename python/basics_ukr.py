# basic syntax

# Python — це динамічно типізована мова

# Вона керується відступами (Indentation) — 1 таб або 4 пробіли

    # Scope Definition (Визначення області видимості) — це як {} у C
        # якщо рядок має більший відступ, ніж попередній, 
        # він "вкладений" (nested) у попередній блок.

    # The Golden Rule of 4 Spaces (Золоте правило 4 пробілів)
        # PEP8 вимагає використовувати 4 пробіли для табуляції

    # The Colon Connection (Зв'язок з двокрапкою)
        # Відступ завжди йде після рядка, що закінчується двокрапкою `:`

    # IndentationError
        # Це тип помилки, яка виникає ще до запуску програми 
        # (на етапі парсингу), якщо відступи розставлені хаотично.



# Comments (Коментарі)

"""
Коментарі — це рядки коду, які інтерпретатор Python повністю ігнорує.
Вони існують виключно для людей (вас, ваших колег або вас самих через два тижні),
щоб пояснити логіку, "законсервувати" частину коду або створити документацію.
"""

# Single-Line Comments (Однорядкові коментарі)
    # вони починаються з символу решітки (#) 
    # все, що написано після цього символу в тому ж рядку, не виконується

    # Inline: пишуться праворуч від коду. 
        # Використовуйте обережно, щоб не захаращувати код.

    # Block: пишуться над кодом, який вони пояснюють.

# Це окремий коментар, що пояснює блок нижче.
x = 5  # А це inline-коментар

# Docstrings (Рядки документації)
    # це спеціальний тип коментарів
    # вони беруться в потрійні лапки """...""" або '''...'''

    # на відміну від звичайних коментарів, Docstrings прив'язані до об'єктів 
    # (функцій, класів, модулів) 
    # і стають частиною їхньої мета-інформації.

    # їх можна прочитати програмно через атрибут .__doc__ або 
    # викликавши функцію help() 
    # це стандарт для створення професійної документації коду


def calculate_tax(income):
    """
    Розраховує податок на прибуток.
    Приймає: income (int)
    Повертає: tax (float)
    """
    pass


# Commenting Out for debugging (Коментування для відлагодження)
    # ви ставите # перед робочим кодом, 
    # щоб тимчасово вимкнути його виконання, не видаляючи.

# print("Цей рядок зараз не спрацює")
print("А цей спрацює")

# The "Why", Not "What" (Правило "Чому", а не "Що")
    # коментар повинен пояснювати причину рішення або складний алгоритм

    # Погано: 

x = x + 1 # Збільшуємо x на 1 (Це і так очевидно)

    # Добре: 

x = x + 1 # компенсуємо зміщення індексу, 
          # оскільки API рахує з 1 (Пояснює бізнес-логіку)



# Input/Output (Введення/Виведення)
    # це механізми, які перетворюють скрипт із "чорної скриньки" на інтерактивну програму 
    # базовий синтаксис стосується взаємодії з текстовою консоллю (терміналом)

# Standard Output (Стандартне виведення)
    # функція print() — це ваш основний інструмент для відображення інформації.

print("Data", "Science")              # Data Science
print("Data", "Science", sep="-")     # Data-Science
print("Loading", end="...")           # Loading... (без переходу на новий рядок)
print("Done")                         # Допише "Done" в той самий рядок

# User Input (Введення користувача)
    # функція input() дозволяє призупинити програму і чекати, 
    # поки користувач щось напише і натисне Enter

    # The String Trap (Пастка рядка): найважливіше правило — input() завжди повертає рядок (str)

age = input("Скільки вам років? ") # Вводимо: 25
# тепер age = "25" (рядок)

# year = 2024 - age  # ПОМИЛКА! Не можна віднімати рядок від числа.

real_age = int(age)  # Конвертуємо в int
year = 2024 - real_age # тепер все працює

# String Formatting (Форматування рядків)
    # у сучасному Python (3.6+), f-strings (форматовані рядкові літерали) є стандартом
    # це спосіб вставити значення змінних у текст без використання громіздких плюсів
    
    # ставимо f перед лапками, 
    # у {} можна писати не тільки змінні, а й прості вирази або виклики методів

name = "Alex"
score = 95.5

# Старий (поганий) спосіб:
print("Користувач " + name + " отримав " + str(score) + " балів") 

# Сучасний (f-string) спосіб:
print(f"Користувач {name} отримав {score} балів")

# Навіть так:
print(f"Подвоєний результат: {score * 2}")



# Python Reserved Words (Зарезервовані слова Python)
    # це зарезервовані слова, і ви не можете використовувати їх як імена констант, 
        # змінних або будь-яких інших ідентифікаторів. 
    
    # усі ключові слова Python пишуться лише маленькими літерами 
        # за винятком True, False та None
        
"""
| Ключове слово | Опис                                                |
|---------------|----------------------------------------------------------------|
| False         | Логічна "Хибність" (0).                                        |
| True          | Логічна "Істина" (1).                                          |
| None          | Позначає "нічого" або відсутність значення.                    |
| and           | Логічне "І" (обидві умови мають бути True).                    |
| as            | Створення псевдоніма (наприклад, import numpy as np).          |
| assert        | Використовується для відлагодження (перевірка умови).          |
| break         | Негайно виходить із циклу.                                     |
| class         | Оголошення нового класу (об'єкта).                             |
| continue      | Переходить до наступної ітерації циклу.                        |
| def           | Оголошення функції.                                            |
| del           | Видалення об'єкта або елемента.                                |
| elif          | Скорочення від "else if" (інакше якщо).                        |
| else          | Блок "інакше" (якщо умова if не справдилась).                  |
| except        | Перехоплення помилок (у блоці try).                            |
| finally       | Блок, який виконується завжди (після try/except).              | 
| for           | Цикл для перебору послідовностей.                              |
| from          | Імпорт конкретних частин з модуля.                             |
| global        | Оголошення змінної як глобальної (доступної всюди).            |
| if            | Умовний оператор "Якщо".                                       |
| import        | Підключення модуля (бібліотеки).                               |
| in            | Перевірка наявності (чи є x "в" y).                            |
| is            | Перевірка ідентичності об'єктів (чи це той самий об'єкт)       |
| lambda        | Створення анонімної (однорядкової) функції.                    |
| nonlocal      | Оголошення змінної із зовнішньої (не глобальної) області.      |
| not           | Логічне заперечення "Не".                                      |
| or            | Логічне "Або" (хоча б одна умова True).                        |
| pass          | "Заглушка". Нічого не робить (коли код синтаксично необхідний).|
| raise         | Примусовий виклик помилки (винятку).                           |
| return        | Повернення результату з функції.                               |
| try           | Початок блоку обробки помилок.                                 |
| while         | Цикл "поки виконується умова".                                 |
| with          | Менеджер контексту (наприклад, для роботи з файлами).          |
| yield         | Повернення значення з функції-генератора (зберігає стан).      |
"""



# Operators (Оператори)

"""
| Тип оператора       | Символи                | Приклад / Пояснення                    |
|---------------------|------------------------|----------------------------------------|
| Арифметичні         | +, -, *, /             | a + b                                  |
| Піднесення до степ. | ** | 2 ** 3 (рез. 8)   |                                        |
| Цілочис. ділення    | //                     | 10 // 3 (результат 3)                  |
| Остача від ділення  | %                      | 10 % 3 (результат 1)                   |
| Порівняння          | ==, !=, >, <, >=, <=   | 5 > 3 (True)                           |
| Логічні             | and, or, not           | True and False                         |
| Присвоєння          | =, +=, -=, *=          | x += 1 (те саме, що x = x + 1)         |
"""



# Variables (Змінні)

score = 100 # score — це змінна (var) зі значенням 100
    # Оператор = означає "присвоїти"
    # Логіка: Спочатку створюється об'єкт праворуч, 
        # а потім йому дається ім'я ліворуч.

# Naming Rules (Правила іменування)
    # можуть містити літери (a-z, A-Z), цифри (0-9) та підкреслення (_)
    # не можуть починатися з цифри (1var — помилка)
    # чутливі до регістру: Data і data — це дві різні змінні.

# Style (Convention) / Стиль: 
    # у Python прийнято використовувати snake_case 
    # (маленькі літери через підкреслення) для звичайних змінних

    # приклад: user_login_count, а не UserLoginCount

# Dynamic Typing (Динамічна типізація)
    # тип прив'язаний до значення (об'єкта), а не до змінної (імені) 
    # це означає, що одна й та сама змінна може вказувати на різні типи даних 
    # протягом життя програми

x = 10        # x посилається на int
x = "Hello"   # тепер x посилається на str (і це ОК)

# Reference Model (Модель посилань)
    # коли ви пишете a = [1, 2] і b = a, 
    # ви не копіюєте список,
    # ви просто чіпляєте другий ярлик (b) на той самий об'єкт у пам'яті



# Data types. Types are categorized: (Типи даних. Категорії:)
    # numeric, sequence, mapping, set, boolean, and binary types 

# Numeric Types (Числові типи)

x = 10              # integer (<class 'int'>)
y = -5234234234234  # може бути наскільки завгодно великим, поки вистачає RAM

pi = 3.14     # float (<class 'float'>)
sci = 1.2e-5  # науковий запис

z = 2 + 3j    # complex (<class 'complex'>) - комплексні числа

# Python не має типу 'double' 
    # ви можете використовувати double через numpy (np.float64 - double)


# Sequence Types (Послідовності)

my_list = [1, "a", 3.5] # list (mutable/змінний) (<class 'list'>)  
    # може містити елементи різних типів (int, string, float, bool, list)

my_tuple = (1, "Hello", 3.14, True, [10, 20]) # tuple (immutable/незмінний) (<class 'tuple'>)
    # може містити елементи різних типів
# або так
my_tuple2 = 12, "bye!", 2.71, (12, 'o'), False # tuple (immutable) (<class 'tuple'>)

r = range(5) # range, генерує 0, 1, 2, 3, (<class 'range'>)

s = "Hello" # string (<class 'str'>) Незмінна послідовність Unicode символів (текст)
    # технічно, це масив символів


# Mapping Types (Типи відображення)

user = {"name": "Ivan", "age": 25} # dictionary (mutable) (<class 'dict'>)
    # працює як ключ:значення
    # Ключі повинні бути унікальними та незмінними 
    # напр. рядки, числа, кортежі. Значення можуть бути будь-якими.


# Set Types (Множини)

# Невпорядковані колекції унікальних елементів 
    # Головна фішка — миттєва перевірка наявності елемента 
    # та математичні операції (перетин, об'єднання)

my_set = {1, 2, 3, 3} # set (mutable) (<class 'set'>)

fs = frozenset([1, 2, 3]) # frozenset (immutable) (<class 'frozenset'>)
    # оскільки він незмінний, його можна використовувати як ключ у словнику


# Boolean Type (Логічний тип)
    # Тільки 2 значення, використовується для перевірки умов

x = True    # True (Істина)  (<class 'bool'>)
y = False   # False (Хибність) (<class 'bool'>)

    # у Python, bool є підкласом int
    # True — це 1, а False — це 0
    # тому:

z = True + True   # 2 (<class 'int'>)
t = True + False  # 1 (<class 'int'>)


# Binary Types (Бінарні типи)
    # для роботи з "сирими" даними (зображення, файли, мережеві пакети)
    # де важливо оперувати байтами, а не символами

    # bytes — незмінна послідовність байтів (числа від 0 до 255)

b = b'Hello' # послідовність байтів (<class 'bytes'>)
    # також коли дані треба передати через мережу (TCP/UDP)

    # bytearray — змінна послідовність байтів. Окремі байти можна міняти

ba = bytearray(5) # bytearray(b'\x00\x00\x00\x00\x00') (<class 'bytearray'>)
    # масив із 5 нульових байтів

    # memoryview — це "вікно" у буфер байтів 
                   # (напр., bytes, bytearray, array.array) 
                   # без створення нової копії даних.

# !Для 'bytes', 'memoryview' буде тільки для читання, бо 'bytes' незмінні!

mv = memoryview(b)  # створюємо memoryview (<class 'memoryview'>)
    # Це інструмент для оптимізації роботи з великими обсягами даних

print(mv[0])                # 72  → ASCII код 'H'
print(mv[1:4])              # <memory at 0x...>, але можна конвертувати в bytes:
print(mv[1:4].tobytes())    # b'ell'


# Python Data Types Cheat Sheet (Шпаргалка)
"""
| Категорія       | Тип(и)                  | Змінний? (Mutable)           |
|-----------------|-------------------------|------------------------------|
| Numeric         | int, float, complex     | Ні (створюється новий об'єкт)|
| Sequence        | str, tuple, range       | Ні                           |
| Sequence        | list                    | Так                          |
| Mapping         | dict                    | Так                          |
| Set             | set                     | Так                          |
| Set             | frozenset               | Ні                           |
| Boolean         | bool                    | Ні                           |
| Binary          | bytes                   | Ні                           |
| Binary          | bytearray               | Так                          |
| Binary          | memoryview              | Так                          |
"""



# Conditional Statements (Умовні конструкції)

# The if Statement
    # ключове слово if, умова (вираз, що повертає True/False), 
    # і обов'язкова двокрапка :


# The elif Clause 
    # скорочення від "else if" (інакше якщо)
    # це унікальна риса Python (інші мови часто пишуть else if).


# The else Clause
    # це варіант "у всіх інших випадках"
    # не приймає жодних умов
    # гарантовано спрацює, якщо жодна з перевірок вище 
        # (if та elif) не повернула True. Це ваш "план Б"


status_code = 404

if status_code == 200:
    print("Успіх! Дані отримано")
elif status_code == 404:
    print("Помилка: Ресурс не знайдено")
elif status_code == 500:
    print("Помилка сервера: Ми працюємо над цим")
else:
    # Цей блок спрацює для всіх інших кодів (403, 401, 301 тощо)
    print(f"Невідомий статус: {status_code}")
    

# Truth Value Testing (Перевірка істинності)
    # це дуже "пайтонівська" концепція
    # в умову if можна передавати не тільки порівняння (x > 5), 
    # а й прості об'єкти. Python автоматично конвертує їх у bool

    # Falsy values (Сприймаються як False)
        # число 0 або 0.0.
        # порожні контейнери: "" (порожній рядок), [] (список), () (кортеж), {} (словник).
        # None
        # False
    
    # Truthy values (Сприймаються як True)
        # будь-які ненульові числа (навіть -1)
        # будь-які непорожні рядки чи списки


# Nested Conditions (Вкладені умови)
    # ви можете розмістити if всередині іншого if
    # кожен рівень вкладеності вимагає додаткового відступу (4 пробіли)

x = 10
if x > 0:
    print("True")
    if x % 2 == 0:
        print("і парне")



# Loops (Цикли)
    # цикли дозволяють комп'ютерам робити те, що вони вміють найкраще: 
    # швидко і точно повторювати одну й ту ж дію тисячі разів


# The for Loop
    # у Python цикл for працює трохи інакше, ніж у C++ чи Java
    # це ітератор. Він не просто "рахує від 0 до 10"; 
    # він проходить по елементах будь-якої послідовності (списку, рядка, файлу)


fruits = ["Apple", "Banana", "Cherry"]

for fruit in fruits:
    # На першій ітерації fruit = "Apple"
    # На другій = "Banana"...
    print(f"Я люблю {fruit}")


# The range() Function
    # якщо вам просто треба повторити дію N разів (як класичний цикл у C), 
    # використовуйте генератор чисел range()

    # range(start, stop, step)
        # start: з чого почати (за замовчуванням 0)
        # stop: де зупинитись (не включаючи це число!)
        # step: крок (за замовчуванням 1)


# рахуємо від 0 до 4
for i in range(5): 
    print(i) # 0, 1, 2, 3, 4

# рахуємо парні числа від 10 до 20
for i in range(10, 21, 2):
    print(i) # 10, 12, ... 18, 20


# The while Loop
    # використовується, коли ми не знаємо, скільки разів треба повторити дію, 
    # але знаємо умову, за якої її треба виконувати

    # поки (while) ця умова True, крутити цикл

    # Infinite Loop (Нескінченний цикл): 
        # якщо умова ніколи не стане False (наприклад, while True:), 
        # програма зависне. Це часто використовується для серверів, які повинні працювати вічно
    

battery = 100

while battery > 0:
    print(f"Заряд: {battery}% - Працюємо...")
    battery -= 20 # Важливо змінювати умову, щоб цикл колись зупинився!

print("Батарея розряджена")


# Loop Control (Керування циклом)
    # іноді треба втрутитися в стандартний потік циклу.

    # break: "Стоп-кран". Негайно викидає вас із циклу, припиняючи його виконання.

    # continue: "Пропустити хід". Негайно переходить до наступної ітерації, 
        # ігноруючи решту коду в поточному колі.


for i in range(10):
    if i == 3:
        continue # пропускаємо трійку, продовжуємо друкувати
    if i == 8:
        break    # дійшли до 8 і повністю зупинили цикл
    print(i)


# The else Block in Loops (Блок else у циклах)
    # Це унікальна і часто незрозуміла фішка Python. Цикли можуть мати блок else!

    # коли спрацьовує: тільки якщо цикл завершився природним шляхом 
        # тобто не був зупинений через break

    # приклад: пошук чогось у списку


my_list = [1, 3, 5]
target = 4

for num in my_list:
    if num == target:
        print("Знайшов!")
        break
else:
    # Це спрацює, бо break так і не був викликаний
    print("Числа немає в списку")
